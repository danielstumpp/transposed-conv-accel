#include "TransposeConv2d.hpp"
#include <iostream>

#define MAX(A, B) ((A >= B) ? A : B)
#define MIN(A, B) ((A >= B) ? B : A)

void TransposeConv2d(DTYPE in[CFG::in_channels][CFG::in_size][CFG::in_size],
                     DTYPE bias[CFG::out_channels],
                     DTYPE kernel[CFG::out_channels][CFG::in_channels][CFG::kernel_size][CFG::kernel_size],
                     DTYPE out[CFG::out_channels][CFG::out_size][CFG::out_size])
{
    // This first part is where most of the weird stuff happens
    constexpr int inpad = MAX(CFG::kernel_size - CFG::pad - 1, 0);                           
    constexpr int pin_size = CFG::in_size + (CFG::in_size-1)*(CFG::stride - 1) +  2*inpad;  
    DTYPE padded_in[CFG::in_channels][pin_size][pin_size];
    for (int c = 0; c < CFG::in_channels; ++c){
        for (int i = 0; i < pin_size; ++i){
            for (int j = 0; j < pin_size; ++j){
                padded_in[c][i][j] = 0;
            }
        }
    }
    
    for (int c = 0; c < CFG::in_channels; ++c){
        for (int h = 0; h < CFG::in_size; ++h){
            for (int w = 0; w < CFG::in_size; ++w){
                padded_in[c][inpad + h*CFG::stride][inpad + w*CFG::stride] = in[c][h][w]; 
            }
        }
    }

    for (int i = 0; i < CFG::out_channels; ++i){
        for (int h = 0; h < CFG::out_size; ++h){
            for (int w = 0; w < CFG::out_size; ++w){
                out[i][h][w] = bias[i];
            }
        }
    }
    

    for (int i = 0; i < CFG::out_channels; ++i){
        for (int j = 0; j < CFG::in_channels; ++j){
            for (int h = 0; h < CFG::out_size; ++h){
                for (int w = 0; w < CFG::out_size; ++w) {
                    for (int p = 0; p < CFG::kernel_size; ++p) {
                        for (int q = 0; q < CFG::kernel_size; ++q)
                        {
                            out[i][h][w] += kernel[i][j][p][q] * padded_in[j][h + p][w + q];
                        }
                    }
                }
            }
        }
    }
    
}

void TransposeConv2d_arr_gold(int16_t *in, int16_t *bias, int16_t *kernel, int16_t *out)
{


    // This first part is where most of the weird stuff happens
    const int inpad = MAX(CFG::kernel_size - CFG::pad - 1, 0);                           
    const int pin_size = CFG::in_size + (CFG::in_size-1)*(CFG::stride - 1) +  2*inpad;
    int16_t padded_in[CFG::cTile][pin_size][pin_size];

    for (int i = 0; i < CFG::out_channels; ++i){
        for (int h = 0; h < CFG::out_size; ++h){
            for (int w = 0; w < CFG::out_size; ++w){
                out[i*CFG::out_size*CFG::out_size + h*CFG::out_size + w] = bias[i];
            }
        }
    }
    
    
    for (int ct = 0; ct < CFG::in_channels; ct += CFG::cTile){
        for (int c = 0; c < CFG::cTile; ++c){
            for (int i = 0; i < pin_size; ++i){
                for (int j = 0; j < pin_size; ++j){
                    padded_in[c][i][j] = 0;
                }
            }
        }

        for (int c = 0; c < CFG::cTile; ++c){
            for (int h = 0; h < CFG::in_size; ++h){
                for (int w = 0; w < CFG::in_size; ++w){
                    padded_in[c][inpad + h*CFG::stride][inpad + w*CFG::stride] = in[(c+ct)*CFG::in_size*CFG::in_size + h*CFG::in_size + w]; 
                }
            }
        }

        for (int i = 0; i < CFG::out_channels; ++i){
            for (int j = 0; j < CFG::cTile; ++j){
                for (int h = 0; h < CFG::out_size; ++h){
                    for (int w = 0; w < CFG::out_size; ++w) {
                        for (int p = 0; p < CFG::kernel_size; ++p) {
                            for (int q = 0; q < CFG::kernel_size; ++q)
                            {
                                out[i * CFG::out_size * CFG::out_size + h * CFG::out_size + w] +=
                                    kernel[(i * CFG::in_channels * CFG::kernel_size * CFG::kernel_size) + ((j + ct) * CFG::kernel_size * CFG::kernel_size) + (p * CFG::kernel_size) + q] * padded_in[j][h + p][w + q];
                            }
                        }
                    }
                }
            }
        }
    }

}



// Array indexing implementation equivalent to above
// Useful to generate ground truth SW values with inputs generated by host code 
void TransposeConv2d_arr(DTYPE *in, DTYPE *bias, DTYPE *kernel, DTYPE *out)
{

    static const int inpad = MAX(CFG::kernel_size - CFG::pad - 1, 0);

    int16_t weights_block[CFG::ocTile][CFG::in_channels][CFG::kernel_size][CFG::kernel_size];
    int16_t out_block[CFG::ocTile][CFG::osTile][CFG::osTile];
    int16_t in_block[CFG::in_channels][CFG::osTile/CFG::stride][CFG::osTile/CFG::stride];

    for (int ht = 0; ht < CFG::out_size; ht += CFG::osTile){
        for (int wt = 0; wt < CFG::out_size; wt += CFG::osTile){
            for (int it = 0; it < CFG::out_channels; it += CFG::ocTile){

                // load bias into output block
                for (int h = ht; h < MIN(ht + CFG::osTile, CFG::out_size); ++h){
                    for (int w = wt; w < MIN(wt + CFG::osTile, CFG::out_size); ++w){
                        for (int i = it; i < MIN(it + CFG::ocTile, CFG::out_channels); ++i){
                            out_block[i - it][h - ht][w - wt] = bias[i];
                        }
                    }
                }

                // load kernel weights
                for (int i = it; i < MIN(it + CFG::ocTile, CFG::out_channels); ++i){
                    for (int j = 0; j < CFG::in_channels; ++j){
                        for (int p = 0; p < CFG::kernel_size; ++p){
                            for (int q = 0; q < CFG::kernel_size; ++q){
                                weights_block[i - it][j][p][q] = kernel[(i * CFG::in_channels * CFG::kernel_size * CFG::kernel_size) + (j * CFG::kernel_size * CFG::kernel_size) + (p * CFG::kernel_size) + q];
                            }
                        }
                    }
                }

                // load input features
                for (int h = ht; h < MIN(ht + CFG::osTile, CFG::out_size); ++h){
                    for (int w = wt; w < MIN(wt + CFG::osTile, CFG::out_size); ++w){
                        for (int j = 0; j < CFG::in_channels; ++j){
                            for (int p = 0; p < CFG::kernel_size; ++p) {
                                for (int q = 0; q < CFG::kernel_size; ++q){
                                    if ((h + p) % CFG::stride == inpad && (w+q) % CFG::stride == inpad){
                                        in_block[j][(h - ht) / CFG::stride][(w - wt) / CFG::stride] = in[j * CFG::in_size * CFG::in_size + (h / CFG::stride) * CFG::in_size + (w / CFG::stride)];
                                    }   
                                }
                            }
                        }
                    }
                }

                // perform convolution
                for (int h = ht; h < MIN(ht + CFG::osTile, CFG::out_size); ++h){
                    for (int w = wt; w < MIN(wt + CFG::osTile, CFG::out_size); ++w){
                        for (int i = it; i < MIN(it + CFG::ocTile, CFG::out_channels); ++i){
                            for (int j = 0; j < CFG::in_channels; ++j){
                                for (int p = 0; p < CFG::kernel_size; ++p) {
                                    for (int q = 0; q < CFG::kernel_size; ++q)
                                    {
                                        if ((h + p) % CFG::stride == inpad && (w+q) % CFG::stride == inpad){
                                            out_block[i - it][h - ht][w - wt] += weights_block[i - it][j][p][q] * in_block[j][(h - ht) / CFG::stride][(w - wt) / CFG::stride];
                                        }                           
                                    }
                                }
                            }
                        }
                    }
                } 

                // write output to DRAM
                for (int h = ht; h < MIN(ht + CFG::osTile, CFG::out_size); ++h){
                    for (int w = wt; w < MIN(wt + CFG::osTile, CFG::out_size); ++w){
                        for (int i = it; i < MIN(it + CFG::ocTile, CFG::out_channels); ++i){
                            out[i * CFG::out_size * CFG::out_size + h * CFG::out_size + w] = out_block[i - it][h - ht][w - wt];
                        }
                    }
                }
            }  
        }
    }                          

    
    
}
